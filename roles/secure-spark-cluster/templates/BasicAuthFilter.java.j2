package com.datanexus.servlet;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

import java.nio.charset.StandardCharsets;

import java.util.Arrays;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.servlet.Filter;
import javax.servlet.FilterConfig;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.codec.digest.Crypt;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.codec.digest.Md5Crypt;

import com.datanexus.servlet.http.BasicAuthHttpServletRequest;

/*
 * A servlet filter that performs basic authentication based on the key-value
 * pairs that are found in the {{spark_dir}}/conf/.htpasswd file
 */
public class BasicAuthFilter implements Filter {

    private final static String _realm = "Apache Spark";
    private final static String htpasswdFileName = "{{spark_dir}}/conf/.htpasswd";
    private final static Pattern HTPASSWD_ENTRY = Pattern.compile("^([^:]+):(.+)");

    /* Username and encrypted passwords; loaded from Apache htpasswd file */
    private Map<String, String> userPasswords = new HashMap<>();

    /* timestamp for when the htpasswdFile was last modified */
    private long htpasswdFileLastModified = -1L;

    @Override
    public void destroy() {
        // Nothing to do.
    }

    @Override
    public void doFilter( final ServletRequest request, final ServletResponse response,
            final FilterChain chain ) throws IOException, ServletException {

        final HttpServletRequest httpRequest = (HttpServletRequest) request;
        final HttpServletResponse httpResponse = (HttpServletResponse) response;

        final String auth = httpRequest.getHeader("Authorization");
        /*
         * if an authorization block was found in the request, and the base64
         * decoded version of that field contains two fields, then pass the
         * request along to the next filter in the chain
         */
        if ( auth != null ) {
            final int index = auth.indexOf(' ');
            if ( index > 0 ) {
                final String firstLine = auth.substring(index).split("\r\n|\r|\n")[0].trim();
                final String[] credentials =
                        (new String(Base64.getDecoder().decode(firstLine.getBytes(StandardCharsets.UTF_8)))).split( ":" );
                if ( authenticate(credentials, new File(htpasswdFileName)) ) {
                    chain.doFilter( new BasicAuthHttpServletRequest(httpRequest, credentials[0], credentials[1]), httpResponse );
                    return;
                }
            }
        }
        /*
         * otherwise, return an error (should trigger authentication)
         */
        httpResponse.setHeader( "WWW-Authenticate", "Basic realm=\"" + _realm + "\"" );
        httpResponse.sendError( HttpServletResponse.SC_UNAUTHORIZED );
    }

    @Override
    public void init( final FilterConfig config ) throws ServletException {

    }

    /**
     * Check if the credentials are valid according to the Apache htpasswd-style credentials file
     *
     */
    private boolean authenticate(String[] credentials, File htpasswdFile) throws IOException {

        // Read in the htpasswd file
        checkReadHtpasswdFile(htpasswdFile);

        String storedPwd = userPasswords.get(credentials[0]);
        if (storedPwd != null) {
            final String passwd = new String(credentials[1]);

            // test Apache MD5 variant encrypted password
            if (storedPwd.startsWith("$apr1$")) {
                return storedPwd.equals(Md5Crypt.apr1Crypt(passwd, storedPwd));
            }

            // test unsalted SHA password
            else if (storedPwd.startsWith("{SHA}")) {
                String passwd64 = org.apache.commons.codec.binary.Base64.encodeBase64String(DigestUtils.sha1(passwd));
                return storedPwd.substring("{SHA}".length()).equals(passwd64);
            }

            // test libc crypt() encoded password
            else if (storedPwd.equals(Crypt.crypt(passwd, storedPwd))) {
                return true;
            }

            // test clear text
            else if (storedPwd.equals(passwd)) {
                return true;
            }
        }

        // Not authenticated
        return false;
    }

    private synchronized void checkReadHtpasswdFile(File htpasswdFile) throws IOException {
        if (!htpasswdFile.exists()) {
            throw new IOException("File does not exist: " + htpasswdFile);
        }

        // Only read it, if the file has been updated ... and the first time called.
        if (htpasswdFile.lastModified() != htpasswdFileLastModified) {

            userPasswords.clear();
            try (Scanner scanner = new Scanner(new FileInputStream(htpasswdFile))) {
                while( scanner.hasNextLine()) {
                    String line = scanner.nextLine().trim();
                    if ( !line.isEmpty() &&  !line.startsWith("#") ) {
                        Matcher m = HTPASSWD_ENTRY.matcher(line);
                        if ( m.matches() ) {
                            userPasswords.put(m.group(1), m.group(2));
                        }
                    }
                }
            }

            // Record time stamp
            htpasswdFileLastModified = htpasswdFile.lastModified();
        }
    }

}
